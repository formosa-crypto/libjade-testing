require "../../common/avx2/expandMask.jazz"
require "../../common/expandS.jazz"
require "../../common/fips202.jazz"
require "../../common/poly.jazz"
require "../../common/rounding.jazz"

require "params.jazz"
require "packing.jazz"

inline
fn decompose(reg u32 a) -> reg u32, reg u32 {
	reg u32 a0;
	reg u32 a1;
	a0, a1 = decompose_gamma2_88(a);
	return a0, a1;
}

inline
fn use_hint(reg u32 a hint)
	-> reg u32
{
	reg u32 a1;
	a1 = use_hint_gamma2_88(a, hint);
	return a1;
}

inline
fn expandMask_poly(reg ptr u32[Li2_polydeg] f, reg ptr u8[64] rho_prime, stack u16 kappa)
	-> reg ptr u32[Li2_polydeg] {
	// TODO: LEFT HERE:
	//   * Make this function 4x parallel
	//   * Add a 4 * Li2_polydeg buffer to the signing code with new y polys
	//   * Update the signing code to use that buffering
	//   * When done, consider parallelizing z-unpack; or
	//     look at other places to parallelize SHA3; or
	//     optimize the NTT.

	stack u32[4 * Li2_polydeg] f_4x;
	reg u64 i;
	reg u32 v32;

	f_4x = expandMask_poly_gamma1_217_4x(f_4x, rho_prime, kappa);
	?{}, i = #set0_64();
	while (i < Li2_polydeg) {
		v32 = f_4x[(int) i];
		f[(int) i] = v32;
		i += 1;
	}
	return f;
}

inline
fn expandS_poly(stack u8[64] rho_prime, reg u16 elem_idx, reg ptr u32[Li2_polydeg] buf)
	-> reg ptr u32[Li2_polydeg] {
    buf = expandSEta2_poly(rho_prime, elem_idx, buf);
	return buf;
}

require "../../common/avx2/expandA_end.jazz"
require "../../common/expandMask_end.jazz"
require "../../common/expandS_end.jazz"
require "../../common/hashing_end.jazz"
require "../../common/poly_end.jazz"
require "../../common/polyvec_end.jazz"
