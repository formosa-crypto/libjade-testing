require "params.jazz"

inline
fn rho_pack(reg ptr u8[32] in out)
	-> reg ptr u8[32]
{
	inline int i;
	reg u8 c;
	for i = 0 to 32 {
		c = in[i];
		out[i] = c;
	}
	return out;
}

fn polyeta_2_pack(reg ptr u32[Li2_polydeg] s1, reg ptr u8[Li2_pack_eta_2_len] dest)
	-> reg ptr u8[Li2_pack_eta_2_len]
{
	reg u32 dest0 dest1 dest2;
	reg u32 t1 t2 t3 t4 t5 t6 t7;

	reg u32 eta;
	reg u32 coeff;

	reg u64 i addr;

	eta = 2;
	i = #set0_64();
	while (i < Li2_polydeg) {
		addr = i;
		addr >>= 3;
		addr = #LEA_64(2*addr + addr);

        // r[3*i+0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
		dest0 = eta; // t0
		dest0 -= s1[(int) i];
		t1 = eta;
		t1 -= s1[(int) i + 1];
		t1 <<= 3;
		dest0 |= t1;
		t2 = eta;
		t2 -= s1[(int) i + 2];
		dest1 = t2;
		t2 <<= 6;
		dest0 |= t2;
		dest[(int) addr + 0] = (8u) dest0;
		
		// r[3*i+1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
		dest1 >>= 2;
		t3 = eta;
		t3 -= s1[(int) i + 3];
		t3 += t3;
		dest1 |= t3;
		t4 = eta;
		t4 -= s1[(int) i + 4];
		t4 <<= 4;
		dest1 |= t4;
		t5 = eta;
		t5 -= s1[(int) i + 5];
		dest2 = t5;
		t5 <<= 7;
		dest1 |= t5;
		dest[(int) addr + 1] = (8u) dest1;
		        
        // r[3*i+2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
		dest2 >>= 1;
		t6 = eta;
		t6 -= s1[(int) i + 6];
		t6 <<= 2;
		dest2 |= t6;
		t7 = eta;
		t7 -= s1[(int) i + 7];
		t7 <<= 5;
		dest2 |= t7;
		dest[(int) addr + 2] = (8u) dest2;

		i += 8;
	}
	return dest;	
}

fn polyeta_4_pack(reg ptr u32[Li2_polydeg] s1, reg ptr u8[Li2_pack_eta_4_len] dest)
	-> reg ptr u8[Li2_pack_eta_4_len]
{
	reg u8 value;

	reg u32 eta lo hi;
	reg u32 coeff;

	reg u64 i addr;

	eta = 4;
	i = #set0_64();
	while (i < Li2_polydeg) {
		coeff = s1[(int) i];
		lo = eta;
		lo -= coeff;

		coeff = s1[(int) i + 1];
		hi = eta;
		hi -= coeff;

		hi <<= 4;
		hi |= lo;

		addr = i;
		addr >>= 1;
		dest[(int) addr] = hi;

		i += 2;
	}
	return dest;
}

fn polyz_unpack_gamma1_217(reg ptr u32[Li2_polydeg] r, reg ptr u8[Li2_pack_zlen_gamma1_217] a)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i in_addr out_addr;
	reg u32 x c32;

	i = 0;
	while (i < Li2_polydeg / 4) {
		in_addr = #LEA_64(8*i + i);
		out_addr = #LEA_64(4*i);

		// r->coeffs[4*i+0]  = a[9*i+0];
		x = (32u) a[(int) in_addr + 0];

		// r->coeffs[4*i+0] |= (uint32_t)a[9*i+1] << 8;
		c32 = (32u) a[(int) in_addr + 1];
		c32 <<= 8;
		x |= c32;

		// r->coeffs[4*i+0] |= (uint32_t)a[9*i+2] << 16;
		c32 = (32u) a[(int) in_addr + 2];
		c32 <<= 16;
		x |= c32;

		// r->coeffs[4*i+0] &= 0x3FFFF;
		x &= 0x3FFFF;

		// r->coeffs[4*i+0] = GAMMA1 - r->coeffs[4*i+0];
		x -= 1 << 17;
		x = -x;
		r[(int) (out_addr + 0)] = x;

		// r->coeffs[4*i+1]  = a[9*i+2] >> 2;
		x = (32u) a[(int) in_addr + 2];
		x >>= 2;

		// r->coeffs[4*i+1] |= (uint32_t)a[9*i+3] << 6;
		c32 = (32u) a[(int) in_addr + 3];
		c32 <<= 6;
		x |= c32;

		// r->coeffs[4*i+1] |= (uint32_t)a[9*i+4] << 14;
		c32 = (32u) a[(int) in_addr + 4];
		c32 <<= 14;
		x |= c32;

		// r->coeffs[4*i+1] &= 0x3FFFF;
		x &= 0x3FFFF;

		// r->coeffs[4*i+1] = GAMMA1 - r->coeffs[4*i+1];
		x -= 1 << 17;
		x = -x;
		r[(int) (out_addr + 1)] = x;

		// r->coeffs[4*i+2]  = a[9*i+4] >> 4;
		x = (32u) a[(int) in_addr + 4];
		x >>= 4;

		// r->coeffs[4*i+2] |= (uint32_t)a[9*i+5] << 4;
		c32 = (32u) a[(int) in_addr + 5];
		c32 <<= 4;
		x |= c32;

		// r->coeffs[4*i+2] |= (uint32_t)a[9*i+6] << 12;
		c32 = (32u) a[(int) in_addr + 6];
		c32 <<= 12;
		x |= c32;

		// r->coeffs[4*i+2] &= 0x3FFFF;
		x &= 0x3FFFF;

		// r->coeffs[4*i+2] = GAMMA1 - r->coeffs[4*i+2];
		x -= 1 << 17;
		x = -x;
		r[(int) (out_addr + 2)] = x;

		// r->coeffs[4*i+3]  = a[9*i+6] >> 6;
		x = (32u) a[(int) in_addr + 6];
		x >>= 6;

		// r->coeffs[4*i+3] |= (uint32_t)a[9*i+7] << 2;
		c32 = (32u) a[(int) in_addr + 7];
		c32 <<= 2;
		x |= c32;

		// r->coeffs[4*i+3] |= (uint32_t)a[9*i+8] << 10;
		c32 = (32u) a[(int) in_addr + 8];
		c32 <<= 10;
		x |= c32;

		// r->coeffs[4*i+3] &= 0x3FFFF;
		x &= 0x3FFFF;

		// r->coeffs[4*i+3] = GAMMA1 - r->coeffs[4*i+3];
		x -= 1 << 17;
		x = -x;
		r[(int) (out_addr + 3)] = x;

		i += 1;
	}

    return r;
}

fn polyz_unpack_gamma1_219(reg ptr u32[Li2_polydeg] r, reg ptr u8[Li2_pack_zlen_gamma1_219] a)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i;
	reg u32 x c32;
	reg u64 addr;

	i = 0;
	while(i < Li2_polydeg / 2) {
		// TODO: replace with: addr = #LEA_64(4*i + i);
		addr = i;
		addr *= 5;

		//r->coeffs[2*i+0]  = a[5*i+0];
		x = (32u) a[(int) addr];

		//r->coeffs[2*i+0] |= (uint32_t)a[5*i+1] << 8;
		addr = i;
		addr *= 5;
		addr += 1;
		c32 = (32u) a[(int) addr];
		c32 <<= 8;
		x |= c32;
		
		//r->coeffs[2*i+0] |= (uint32_t)a[5*i+2] << 16;
		addr = i;
		addr *= 5;
		addr += 2;
		c32 = (32u) a[(int) addr];
		c32 <<= 16;
		x |= c32;

		//r->coeffs[2*i+0] = GAMMA1 - r->coeffs[2*i+0];

		x &= 0xFFFFF;
		x = -x;
		x += 1 << 19;
		addr = i;
		addr *= 2;
		r[(int) addr] = x;

		//r->coeffs[2*i+1]  = a[5*i+2] >> 4;
		addr = i;
		addr *= 5;
		addr += 2;
		x = (32u) a[(int) addr];
		x >>= 4;

		//r->coeffs[2*i+1] |= (uint32_t)a[5*i+3] << 4;
		addr = i;
		addr *= 5;
		addr += 3;
		c32 = (32u) a[(int) addr];
		c32 <<= 4;
		x |= c32;

		//r->coeffs[2*i+1] |= (uint32_t)a[5*i+4] << 12;
		addr = i;
		addr *= 5;
		addr += 4;
		c32 = (32u) a[(int) addr];
		c32 <<= 12;
		x |= c32;

		//r->coeffs[2*i+1] = GAMMA1 - r->coeffs[2*i+1];
		x = -x;
		x += 1 << 19;
		addr = i;
		addr *= 2;
		addr += 1;
		r[(int) addr] = x;

		i += 1;
	}
	return r;
}
