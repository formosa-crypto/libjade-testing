require "params.jazz"

inline
fn rho_pack(reg ptr u8[32] in out)
	-> reg ptr u8[32]
{
	inline int i;
	reg u8 c;
	for i = 0 to 32 {
		c = in[i];
		out[i] = c;
	}
	return out;
}

inline
fn polyz_unpack_gamma1_217(reg ptr u32[Li2_polydeg] r, reg ptr u8[Li2_pack_zlen_gamma1_217] a)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i in_addr out_addr;
	reg u32 x c32;

	i = 0;
	while (i < Li2_polydeg / 4) {
		in_addr = #LEA_64(8*i + i);
		out_addr = #LEA_64(4*i);

		// r->coeffs[4*i+0]  = a[9*i+0];
		x = (32u) a[(int) in_addr + 0];

		// r->coeffs[4*i+0] |= (uint32_t)a[9*i+1] << 8;
		c32 = (32u) a[(int) in_addr + 1];
		c32 <<= 8;
		x |= c32;

		// r->coeffs[4*i+0] |= (uint32_t)a[9*i+2] << 16;
		c32 = (32u) a[(int) in_addr + 2];
		c32 <<= 16;
		x |= c32;

		// r->coeffs[4*i+0] &= 0x3FFFF;
		x &= 0x3FFFF;

		// r->coeffs[4*i+0] = GAMMA1 - r->coeffs[4*i+0];
		x -= 1 << 17;
		x = -x;
		r[(int) (out_addr + 0)] = x;

		// r->coeffs[4*i+1]  = a[9*i+2] >> 2;
		x = (32u) a[(int) in_addr + 2];
		x >>= 2;

		// r->coeffs[4*i+1] |= (uint32_t)a[9*i+3] << 6;
		c32 = (32u) a[(int) in_addr + 3];
		c32 <<= 6;
		x |= c32;

		// r->coeffs[4*i+1] |= (uint32_t)a[9*i+4] << 14;
		c32 = (32u) a[(int) in_addr + 4];
		c32 <<= 14;
		x |= c32;

		// r->coeffs[4*i+1] &= 0x3FFFF;
		x &= 0x3FFFF;

		// r->coeffs[4*i+1] = GAMMA1 - r->coeffs[4*i+1];
		x -= 1 << 17;
		x = -x;
		r[(int) (out_addr + 1)] = x;

		// r->coeffs[4*i+2]  = a[9*i+4] >> 4;
		x = (32u) a[(int) in_addr + 4];
		x >>= 4;

		// r->coeffs[4*i+2] |= (uint32_t)a[9*i+5] << 4;
		c32 = (32u) a[(int) in_addr + 5];
		c32 <<= 4;
		x |= c32;

		// r->coeffs[4*i+2] |= (uint32_t)a[9*i+6] << 12;
		c32 = (32u) a[(int) in_addr + 6];
		c32 <<= 12;
		x |= c32;

		// r->coeffs[4*i+2] &= 0x3FFFF;
		x &= 0x3FFFF;

		// r->coeffs[4*i+2] = GAMMA1 - r->coeffs[4*i+2];
		x -= 1 << 17;
		x = -x;
		r[(int) (out_addr + 2)] = x;

		// r->coeffs[4*i+3]  = a[9*i+6] >> 6;
		x = (32u) a[(int) in_addr + 6];
		x >>= 6;

		// r->coeffs[4*i+3] |= (uint32_t)a[9*i+7] << 2;
		c32 = (32u) a[(int) in_addr + 7];
		c32 <<= 2;
		x |= c32;

		// r->coeffs[4*i+3] |= (uint32_t)a[9*i+8] << 10;
		c32 = (32u) a[(int) in_addr + 8];
		c32 <<= 10;
		x |= c32;

		// r->coeffs[4*i+3] &= 0x3FFFF;
		x &= 0x3FFFF;

		// r->coeffs[4*i+3] = GAMMA1 - r->coeffs[4*i+3];
		x -= 1 << 17;
		x = -x;
		r[(int) (out_addr + 3)] = x;

		i += 1;
	}

    return r;
}

inline
fn polyz_unpack_gamma1_219(reg ptr u32[Li2_polydeg] r, reg ptr u8[Li2_pack_zlen_gamma1_219] a)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i;
	reg u32 x c32;
	reg u64 addr;

	i = 0;
	while(i < Li2_polydeg / 2) {
		// TODO: replace with: addr = #LEA_64(4*i + i);
		addr = i;
		addr *= 5;

		//r->coeffs[2*i+0]  = a[5*i+0];
		x = (32u) a[(int) addr];

		//r->coeffs[2*i+0] |= (uint32_t)a[5*i+1] << 8;
		addr = i;
		addr *= 5;
		addr += 1;
		c32 = (32u) a[(int) addr];
		c32 <<= 8;
		x |= c32;
		
		//r->coeffs[2*i+0] |= (uint32_t)a[5*i+2] << 16;
		addr = i;
		addr *= 5;
		addr += 2;
		c32 = (32u) a[(int) addr];
		c32 <<= 16;
		x |= c32;

		//r->coeffs[2*i+0] = GAMMA1 - r->coeffs[2*i+0];

		x &= 0xFFFFF;
		x = -x;
		x += 1 << 19;
		addr = i;
		addr *= 2;
		r[(int) addr] = x;

		//r->coeffs[2*i+1]  = a[5*i+2] >> 4;
		addr = i;
		addr *= 5;
		addr += 2;
		x = (32u) a[(int) addr];
		x >>= 4;

		//r->coeffs[2*i+1] |= (uint32_t)a[5*i+3] << 4;
		addr = i;
		addr *= 5;
		addr += 3;
		c32 = (32u) a[(int) addr];
		c32 <<= 4;
		x |= c32;

		//r->coeffs[2*i+1] |= (uint32_t)a[5*i+4] << 12;
		addr = i;
		addr *= 5;
		addr += 4;
		c32 = (32u) a[(int) addr];
		c32 <<= 12;
		x |= c32;

		//r->coeffs[2*i+1] = GAMMA1 - r->coeffs[2*i+1];
		x = -x;
		x += 1 << 19;
		addr = i;
		addr *= 2;
		addr += 1;
		r[(int) addr] = x;

		i += 1;
	}
	return r;
}
