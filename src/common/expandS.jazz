require "params.jazz"

// inline
// fn expandSEta2_poly(stack u8[64] rho_prime, reg u16 elem_idx, reg ptr u32[Li2_polydeg] poly)
// 	-> reg ptr u32[Li2_polydeg]
// {
// 	stack u32 coeffs_generated;

// 	// SHA3 state
// 	stack u64[25] state;
// 	reg u64 offset;

// 	// temps
// 	reg u64 j;
// 	reg u8 c1 c2;
// 	reg u32 u32_c1;
// 	reg u32 v;
// 	reg u64 addr;
	
// 	reg u8 c;
// 	reg u32 c32;

// 	state = st0(state);

// 	j = 0;
// 	while(j < 64) {
// 		c1 = rho_prime[(int) j];
// 		state[u8 (int) j] = c1;
// 		j += 1;
// 	}
// 	c = (8u) elem_idx;
// 	state[u8 64] = c;
// 	state[u8 65] = 0;
// 	state[u8 66] = 0x1F;
// 	state[u8 SHAKE256_RATE - 1] = 0x80;

// 	state = __keccakf1600_ref(state);
// 	coeffs_generated = 0;
// 	offset = #set0_64();
// 	while (coeffs_generated < Li2_polydeg) {
// 		if (offset >= SHAKE256_RATE) {
// 			state = __keccakf1600_ref(state);
// 			offset = #set0_64();
// 		}

// 		c = state[u8 (int) offset];
// 		offset += 1;

// 		c32 = (32u)c;
// 		c32 &= 0x0F;
// 		if (c32 < 15) {

// 		}
// 	}
// }

inline
fn expandSEta4_poly(stack u8[64] rho_prime, reg u16 elem_idx, reg ptr u32[Li2_polydeg] poly)
	-> reg ptr u32[Li2_polydeg]
{
	stack u32 coeffs_generated;

	// SHA3 state
	stack u64[25] state;
	reg u64 offset;

	// temps
	reg u64 j;
	reg u8 c1 c2;
	reg u32 u32_c1;
	reg u32 v;
	reg u64 addr;
	
	reg u8 c;
	reg u32 c32;

	state = st0(state);

	j = #set0_64();
	while(j < 64) {
		c1 = rho_prime[(int) j];
		state[u8 (int) j] = c1;
		j += 1;
	}
	c = (8u) elem_idx;
	state[u8 64] = c;
	state[u8 65] = 0;
	state[u8 66] = 0x1F;
	state[u8 SHAKE256_RATE - 1] = 0x80;

	state = __keccakf1600_ref(state);
	coeffs_generated = 0;
	offset = #set0_64();
	while (coeffs_generated < Li2_polydeg) {
		if(offset >= SHAKE256_RATE) {
			state = __keccakf1600_ref(state);
			offset = #set0_64();
		}

		c = state[u8 (int) offset];
		offset += 1;

		c32 = (32u) c;
		c32 &= 0x0F;
		if (c32 < 9) {
			v = 4;
			v -= c32;
			addr = (64u) coeffs_generated;
			poly[(int) addr] = v;
			coeffs_generated += 1;
		}

		if (coeffs_generated < Li2_polydeg) {
			c32 = (32u) c;
			c32 >>= 4;
			if(c32 < 9) {
				v = 4;
				v -= c32;
				addr = (64u) coeffs_generated;
				poly[(int) addr] = v;
				coeffs_generated += 1;
			}
		}
	}

	return poly;
}