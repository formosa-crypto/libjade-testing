require "../common/montgomery.jazz"
require "../common/packing.jazz"

require "params.jazz"

fn pack_s1(reg ptr u32[Li2_l * Li2_polydeg] s1, reg ptr u8[Li2_pack_s1len] dest)
	-> reg ptr u8[Li2_pack_s1len]
{
	inline int ii;
	reg ptr u8[Li2_pack_etalen] buf;
	reg ptr u32[Li2_polydeg] poly;

	for ii = 0 to Li2_l {
		buf = dest[Li2_pack_etalen * ii : Li2_pack_etalen];
		poly = s1[Li2_polydeg * ii : Li2_polydeg];
		dest[Li2_pack_etalen * ii : Li2_pack_etalen] = polyeta_4_pack(poly, buf);
	}
	return dest;
}

fn pack_s2(reg ptr u32[Li2_k * Li2_polydeg] s1, reg ptr u8[Li2_pack_s2len] dest)
	-> reg ptr u8[Li2_pack_s2len]
{
	inline int ii;
	reg ptr u8[Li2_pack_etalen] buf;
	reg ptr u32[Li2_polydeg] poly;

	for ii = 0 to Li2_k {
		buf = dest[Li2_pack_etalen * ii : Li2_pack_etalen];
		poly = s1[Li2_polydeg * ii : Li2_polydeg];
		dest[Li2_pack_etalen * ii : Li2_pack_etalen] = polyeta_4_pack(poly, buf);
	}
	return dest;
}

fn polyeta_unpack(reg ptr u32[Li2_polydeg] r, reg ptr u8[Li2_pack_etalen] a)
	-> reg ptr u32[Li2_polydeg]
{
	r = polyeta_4_unpack(r, a);
	return r;
}

inline
fn polyz_pack(reg ptr u8[Li2_pack_zlen] r, reg ptr u32[Li2_polydeg] a)
	-> reg ptr u8[Li2_pack_zlen]
{
	r = polyz_pack_gamma1_219(r, a);
	return r;
}

inline
fn polyz_unpack(reg ptr u32[Li2_polydeg] r, reg ptr u8[Li2_pack_zlen] a)
	-> reg ptr u32[Li2_polydeg]
{
	r = polyz_unpack_gamma1_219(r, a);
	return r;
}

inline
fn pack_w1(reg ptr u32[Li2_k * Li2_polydeg] w1)
	-> stack u8[Li2_pack_w1len]
{
	stack u8[Li2_pack_w1len] buf;
	stack u64 i;
	reg u64 addr;
	reg u8 c0 c1;
	reg u32 val;

	i = 0;
	while(i < Li2_pack_w1len) {
		addr = i;
		addr *= 2;
		val = w1[(int) addr];
		c0 = (8u) val;
		addr += 1;
		val = w1[(int) addr];
		c1 = (8u) val;

		/* TODO: (note from Ethan): why not this??
		c0 <<= 4;
		c0 += c1;
		*/
		c1 <<= 4;
		c1 += c0;

		addr = i;
		buf[(int) addr] = c1;

		i += 1;
	}
	return buf;
}

require "../common/packing_end.jazz"