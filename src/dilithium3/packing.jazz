require "../common/montgomery.jazz"
require "../common/packing.jazz"

require "params.jazz"

fn pack_s1(reg ptr u32[Li2_l * Li2_polydeg] s1, reg ptr u8[Li2_pack_s1len] dest)
	-> reg ptr u8[Li2_pack_s1len]
{
	reg u8 value;

	reg u32 eta lo hi;
	reg u32 coeff;

	reg u64 i addr;

	eta = Li2_eta;
	?{}, i = #set0_64();
	while (i < Li2_l * Li2_polydeg) {
		coeff = s1[(int) i];
		lo = eta;
		lo -= coeff;

		coeff = s1[(int) i + 1];
		hi = eta;
		hi -= coeff;

		hi <<= 4;
		hi += lo;
		value = (8u) hi;

		addr = i;
		addr >>= 1;
		dest[(int) addr] = value;
		i += 2;
	}
	return dest;
}

fn pack_s2(reg ptr u32[Li2_k * Li2_polydeg] s1, reg ptr u8[Li2_pack_s2len] dest)
	-> reg ptr u8[Li2_pack_s2len]
{
	reg u8 value;

	reg u32 eta lo hi;
	reg u32 coeff;

	reg u64 i addr;

	eta = Li2_eta;
	?{}, i = #set0_64();
	while (i < Li2_k * Li2_polydeg) {
		coeff = s1[(int) i];
		lo = eta;
		lo -= coeff;

		coeff = s1[(int) i + 1];
		hi = eta;
		hi -= coeff;

		hi <<= 4;
		hi += lo;
		value = (8u) hi;

		addr = i;
		addr >>= 1;
		dest[(int) addr] = value;
		i += 2;
	}
	return dest;
}

//Unpacks a component of either s1 or s2
fn polyeta_unpack(reg ptr u32[Li2_polydeg] r, reg ptr u8[Li2_pack_etalen] a)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i;
	reg u32 x;
	reg u64 addr;
	
	i = 0;
	while(i < Li2_polydeg / 2) {

		// r->coeffs[2*i+0] = a[i] & 0x0F;
		x = (32u) a[(int) i];
		x &= 0x0F;
		// r->coeffs[2*i+0] = ETA - r->coeffs[2*i+0];
		x = -x;
		x += Li2_eta;

		addr = i;
		addr *= 2;
		r[(int) addr] = x;

	    // r->coeffs[2*i+1] = a[i] >> 4;
		x = (32u) a[(int) i];
		x >>= 4;
		// r->coeffs[2*i+1] = ETA - r->coeffs[2*i+1];
		x = -x;
		x += Li2_eta;

		addr = i;
		addr *= 2;
		addr += 1;
		r[(int) addr] = x;

		i += 1;
	}
	return r;
}

inline
fn polyz_pack(reg ptr u8[Li2_pack_zlen] r, reg ptr u32[Li2_polydeg] a)
	-> reg ptr u8[Li2_pack_zlen]
{
	stack u64 i;
	reg u64 addr;
	reg u32 v;
	reg u8 c;
	stack u32 t0 t1;

	i = 0;
	while(i < Li2_polydeg / 2) {
		// t[0] = GAMMA1 - a->coeffs[2*i+0];
		addr = i;
		addr *= 2;
		v = a[(int) addr];
		t0 = v;
		t0 = -t0;
		t0 += Li2_gamma1;

		// t[1] = GAMMA1 - a->coeffs[2*i+1];
		addr += 1;
		v = a[(int) addr];
		t1 = v;
		t1 = -t1;
		t1 += Li2_gamma1;

		// r[5*i+0]  = t[0];
		addr = i;
		addr *= 5;
		v = t0;
		r[(int) addr] = (8u) v;

		// r[5*i+1]  = t[0] >> 8;
		v = t0;
		v >>= 8;
		addr += 1;
		r[(int) addr] = (8u) v;

		// r[5*i+2]  = t[0] >> 16;
		v = t0;
		v >>= 16;
		c = (8u) v;

		// r[5*i+2] |= t[1] << 4;
		v = t1;
		v <<= 4;
		c |= (8u) v;
		addr += 1;
		r[(int) addr] = c;

		// r[5*i+3]  = t[1] >> 4;
		v = t1;
		v >>= 4;
		addr += 1;
		r[(int) addr] = (8u) v;

		// r[5*i+4]  = t[1] >> 12;
		v = t1;
		v >>= 12;
		addr += 1;
		r[(int) addr] = (8u) v;

		i += 1;
	}
	return r;
}


inline
fn polyz_unpack(reg ptr u32[Li2_polydeg] r, reg ptr u8[Li2_pack_zlen] a)
	-> reg ptr u32[Li2_polydeg]
{
	r = polyz_unpack_gamma1_219(r, a);
	return r;
}


inline
fn unpack_sk(reg ptr u8[Li2_SK_LEN] sk)
	-> stack u32[Li2_l * Li2_polydeg], //s1
	stack u32[Li2_k * Li2_polydeg], //s2
	stack u32[Li2_k * Li2_polydeg] //t0
{
	stack u32[Li2_l * Li2_polydeg] s1;
	stack u32[Li2_k * Li2_polydeg] s2;
	stack u32[Li2_k * Li2_polydeg] t0;

	// temp vars.
	inline int ii;
	reg ptr u32[Li2_polydeg] poly_to_unpack;

	// unpack sk where needed
	for ii = 0 to Li2_l {
		poly_to_unpack = s1[ii * Li2_polydeg : Li2_polydeg];
		poly_to_unpack = polyeta_unpack(poly_to_unpack,
			sk[96 + ii * Li2_pack_etalen : Li2_pack_etalen]);
		s1[ii * Li2_polydeg : Li2_polydeg] = poly_to_unpack;
	}

	for ii = 0 to Li2_k {
		poly_to_unpack = s2[ii * Li2_polydeg : Li2_polydeg];
		poly_to_unpack = polyeta_unpack(poly_to_unpack,
			sk[Li2_pack_s2loc + ii * Li2_pack_etalen : Li2_pack_etalen]);
		s2[ii * Li2_polydeg : Li2_polydeg] = poly_to_unpack;
	}

	for ii = 0 to Li2_k {
		poly_to_unpack = t0[ii * Li2_polydeg : Li2_polydeg];
		poly_to_unpack = polyt0_unpack(poly_to_unpack,
			sk[Li2_SK_LEN - (Li2_k - ii) * Li2_pack_t0len : Li2_pack_t0len]);
		t0[ii * Li2_polydeg : Li2_polydeg] = poly_to_unpack;
	}

	return s1, s2, t0;
}

inline
fn pack_signature(reg ptr u8[32] c_tilde,
		reg ptr u32[Li2_l * Li2_polydeg] z,
		reg ptr u32[Li2_k * Li2_polydeg] h)
	-> stack u8[Li2_SIGN_LEN]
{
	stack u8[Li2_SIGN_LEN] signature;
	reg u8 c;
	reg ptr u8[Li2_pack_zlen] z_buf;
	reg ptr u32[Li2_polydeg] z_to_pack;
	reg u64 i;
	inline int ii;
	stack u8 k;
	stack u64 j;
	reg u64 reg_j;
	reg u64 addr;
	reg u32 coeff;

	i = 0;
	while(i < 32) {
		c = c_tilde[(int) i];
		signature[(int) i] = c;
		i += 1;
	}

	for ii = 0 to Li2_l {
		z_buf = signature[32 + Li2_pack_zlen * ii : Li2_pack_zlen];
		z_to_pack = z[ii * Li2_polydeg : Li2_polydeg];
		z_buf = polyz_pack(z_buf, z_to_pack);
		signature[32 + Li2_pack_zlen * ii : Li2_pack_zlen] = z_buf;
	}

	i = 0;
	while(i < Li2_omega + Li2_k) {
		signature[(int) (Li2_pack_hstart + i)] = 0;
		i += 1;
	}
	/*
	k = 0;
	for(i = 0; i < K; ++i) {
		for(j = 0; j < N; ++j)
			if(h->vec[i].coeffs[j] != 0)
				sig[k++] = j;
		sig[OMEGA + i] = k;
	}
	*/

	k = 0;
	i = 0;
	while(i < Li2_k) {
		j = 0;
		while(j < Li2_polydeg) {
			addr = Li2_polydeg;
			addr *= i;
			reg_j = j;
			addr += reg_j;
			coeff = h[(int) addr];
			if(coeff != 0) {
				reg_j = j;
				c = (8u) reg_j;
				addr = (64u) k;
				signature[(int) (Li2_pack_hstart + addr)] = c;
				k += 1;
			}
			j += 1;
		}
		signature[(int) (Li2_pack_hstart + Li2_omega + i)] = k;
		i += 1;
	}

	return signature;
}

inline
fn pack_w1(reg ptr u32[Li2_k * Li2_polydeg] w1)
	-> stack u8[Li2_pack_w1len]
{
	stack u8[Li2_pack_w1len] buf;
	stack u64 i;
	reg u64 addr;
	reg u8 c0 c1;
	reg u32 val;

	i = 0;
	while(i < Li2_pack_w1len) {
		addr = i;
		addr *= 2;
		val = w1[(int) addr];
		c0 = (8u) val;
		addr += 1;
		val = w1[(int) addr];
		c1 = (8u) val;

		/* why not this??
		c0 <<= 4;
		c0 += c1;
		*/
		c1 <<= 4;
		c1 += c0;

		addr = i;
		buf[(int) addr] = c1;

		i += 1;
	}
	return buf;
}
